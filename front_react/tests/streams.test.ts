import {describe, expect, it} from '@effect/vitest';
import {Console, Duration, Effect, Fiber, PubSub, Queue, Stream} from 'effect';
import log from 'loglevel';

log.setLevel('debug')

describe('Streams', () => {
  it.live('1 stream/1 subscription from queue', () => Effect.gen(function* () {
    const queue: Queue.Queue<number> = yield* Queue.bounded<number>(100)
    const stream: Stream.Stream<number> = Stream.fromQueue(queue)
    const result1 = Array<number>()
    const sub1 = Stream.runForEach(stream, n => Effect.succeed(result1.push(n)))
    const fork1 = Effect.runFork(sub1)
    log.debug('forked')
    yield* Queue.offerAll(queue, [1, 2, 3, 4, 5])
    log.debug('offered')
    yield* Effect.sleep(Duration.millis(100))
    expect(true).toBe(true)
    log.debug('slept')
    yield* Queue.shutdown(queue)
    log.debug('shutdown')
    yield* fork1
    log.debug('joined')
    expect(result1).toEqual([1, 2, 3, 4, 5])
  }))
  it.live('1 stream/2 subscription from queue', () => Effect.gen(function* () {
    const queue: Queue.Queue<number> = yield* Queue.bounded<number>(100)
    const stream: Stream.Stream<number> = Stream.fromQueue(queue)
    const result1 = Array<number>()
    const result2 = Array<number>()
    const sub1 = Stream.runForEach(stream, n => Effect.succeed(result1.push(n)))
    const sub2 = Stream.runForEach(stream, n => Effect.succeed(result2.push(n)))
    const fork1 = Effect.runFork(sub1)
    const fork2 = Effect.runFork(sub2)
    yield* Queue.offerAll(queue, [1, 2, 3, 4, 5])
    yield* Effect.sleep(100)
    yield* Queue.shutdown(queue)
    yield* fork1
    yield* fork2
    expect(result1).toEqual([1, 2, 3, 4, 5])
    expect(result2).toEqual([])
  }))
  it.live('2 stream/2 subscription from queue', () => Effect.gen(function* () {
    const queue: Queue.Queue<number> = yield* Queue.bounded<number>(100)
    const stream1: Stream.Stream<number> = Stream.fromQueue(queue)
    const stream2: Stream.Stream<number> = Stream.fromQueue(queue)
    const result1 = Array<number>()
    const result2 = Array<number>()
    const sub1 = Stream.runForEach(stream1, n => Effect.succeed(result1.push(n)))
    const sub2 = Stream.runForEach(stream2, n => Effect.succeed(result2.push(n)))
    const fork1 = Effect.runFork(sub1)
    const fork2 = Effect.runFork(sub2)
    yield* Queue.offerAll(queue, [1, 2, 3, 4, 5])
    yield* Effect.sleep(100)
    yield* Queue.shutdown(queue)
    yield* fork1
    yield* fork2
    expect(result1).toEqual([1, 2, 3, 4, 5])
    expect(result2).toEqual([])
  }))
  it.scopedLive('1 pubsub/2 collectors', () => Effect.gen(function* () {
    const pubsub = yield* PubSub.unbounded<number>()
    const dequeue1 = yield* PubSub.subscribe(pubsub)
    const dequeue2 = yield* PubSub.subscribe(pubsub)
    const result1 = Array<number>()
    const result2 = Array<number>()
    console.log('subscribed')
    const fiber1 = Effect.runFork(Effect.gen(function* () {
      while (true) {
        console.log('taking from dequeue1')
        const n = yield* Queue.take(dequeue1)
        console.log('took from dequeue1', n)
        result1.push(n)
      }
    }))
    console.log('forked')
    const fiber2 = Effect.runFork(Effect.gen(function* () {
      while (true) {
        console.log('taking from dequeue2')
        const n = yield* Queue.take(dequeue2)
        console.log('took from dequeue2', n)
        result2.push(n)
      }
    }))
    console.log('forked')
    yield* PubSub.publishAll(pubsub, [1, 2, 3, 4, 5])
    console.log('published')
    yield* Effect.sleep(100)
    console.log('slept')
    yield* PubSub.shutdown(pubsub)
    console.log('shutdown')
    yield* Fiber.join(fiber1).pipe(
      Effect.tapErrorCause(e => Console.log('fiber1 ', e.toString())),
      Effect.catchAllCause(() => Effect.succeed(void 0))
    )
    console.log('joined')
    yield* Fiber.join(fiber2).pipe(
      Effect.tapErrorCause(e => Console.log('fiber1 ', e.toString())),
      Effect.catchAllCause(() => Effect.succeed(void 0))
    )
    console.log('joined')
    expect(result1).toEqual([1, 2, 3, 4, 5])
    expect(result2).toEqual([1, 2, 3, 4, 5])
  }))
  it.live('1 stream/1 subscription from PubSub', () => Effect.gen(function* () {
    const pubsub = yield* PubSub.unbounded<number>()
    const stream: Stream.Stream<number> = Stream.fromPubSub(pubsub)
    const result1 = Array<number>()
    const sub1 = Stream.runForEach(stream, n => {
      console.log('sub1', n)
      return Effect.succeed(result1.push(n))
    })
    const fork1 = Effect.runFork(sub1)
    yield* Effect.yieldNow()
    yield* PubSub.publishAll(pubsub, [1, 2, 3, 4, 5])
    yield* Effect.sleep(100)
    console.log('sleeped')
    yield* PubSub.shutdown(pubsub)
    console.log('shutdowned')
    yield* Fiber.join(fork1)
    console.log('joined')
    expect(result1).toEqual([1, 2, 3, 4, 5])
  }))
  it.live('1 stream/2 subscription from PubSub', () => Effect.gen(function* () {
    const pubsub = yield* PubSub.unbounded<number>()
    const stream: Stream.Stream<number> = Stream.fromPubSub(pubsub)
    const result1 = Array<number>()
    const result2 = Array<number>()
    const sub1 = Stream.runForEach(stream, n => Effect.succeed(result1.push(n)))
    const sub2 = Stream.runForEach(stream, n => Effect.succeed(result2.push(n)))
    const fork1 = Effect.runFork(sub1)
    const fork2 = Effect.runFork(sub2)
    yield* Effect.yieldNow()
    yield* PubSub.publishAll(pubsub, [1, 2, 3, 4, 5])
    yield* Effect.sleep(100)
    console.log('sleeped')
    yield* PubSub.shutdown(pubsub)
    console.log('shutdowned')
    yield* Fiber.join(fork1)
    yield* Fiber.join(fork2)
    console.log('joined')
    expect(result1).toEqual([1, 2, 3, 4, 5])
    expect(result2).toEqual([1, 2, 3, 4, 5])
  }))
  it.live('2 stream/2 subscription from PubSub', () => Effect.gen(function* () {
    const pubsub = yield* PubSub.sliding<number>(100)
    const stream1: Stream.Stream<number> = Stream.fromPubSub(pubsub)
    const stream2: Stream.Stream<number> = Stream.fromPubSub(pubsub)
    const result1 = Array<number>()
    const result2 = Array<number>()
    const sub1 = Stream.runForEach(stream1, n => Effect.succeed(result1.push(n)))
    const sub2 = Stream.runForEach(stream2, n => Effect.succeed(result2.push(n)))
    const fork1 = Effect.runFork(sub1)
    const fork2 = Effect.runFork(sub2)
    yield* Effect.yieldNow()
    yield* PubSub.publishAll(pubsub, [1, 2, 3, 4, 5])
    yield* Effect.sleep(100)
    yield* PubSub.shutdown(pubsub)
    yield* fork1
    yield* fork2
    expect(result1).toEqual([1, 2, 3, 4, 5])
    expect(result2).toEqual([1, 2, 3, 4, 5])
  }))
})
